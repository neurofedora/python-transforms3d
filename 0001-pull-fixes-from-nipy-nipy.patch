From 2090157eb6a423ecd57029f41ecce553dc8fb69d Mon Sep 17 00:00:00 2001
From: Igor Gnatenko <i.gnatenko.brain@gmail.com>
Date: Sun, 1 Nov 2015 14:57:45 +0100
Subject: [PATCH] pull fixes from nipy/nipy

Commits:

commit c7ae00435ef1134cee28eb0d31d2f1a253328f6b
Author: Matthew Brett <matthew.brett@gmail.com>

    RF: more Python 3 fixes from python-modernize

commit 37831e587f88a928912fc9b82ba1e813eb7c9160
Author: Matthew Brett <matthew.brett@gmail.com>

    RF: lists from Python 3 iterators

commit 54953d06312dd4a044d47c20401e6f7eaa959232
Author: Matthew Brett <matthew.brett@gmail.com>

    RF: get reduce from function functools

commit 27271ad67ae58f23c4d606c43ece171a2adb53b5
Author: Matthew Brett <matthew.brett@gmail.com>

    RF: delete implemention of itertools.permutations

commit 4f74d7c7da01c5ccc6b31f47aebd00e8ac009215
Author: Matthew Brett <matthew.brett@gmail.com>

    BF - fix doctest floating point display error

commit 33aef079855462498432f611e00953dde386bc12
Author: Alexis Roche <alexis.roche@gmail.com>

    apply Matthew's suggested fix for infinite quaternions

commit 96cea13ac22cbfc369c6ab2c7f854528be9d8ad9
Author: Alexis Roche <alexis.roche@gmail.com>

    fixing nan issue in quaterions (from externals)

commit 81f6b0c750744b4296bc8d8f816f7e58567c82c7
Author: Matthew Brett <matthew.brett@gmail.com>

    BF - remove in-place divide - numpy 2 casting rule

commit 5bcd4dd6ef36e72aec2c7ae6e77bea6d428d2c8c
Author: Yaroslav Halchenko <debian@onerussian.com>

    BF: add needed setup.py and __init__.py to guarantee installation of tests

commit 2ff49be4ecf3b322bac79aff8875378515415600
Author: Gael varoquaux <gael.varoquaux@normalesup.org>

    BUG: Fix imports in taitbryan

commit 98be1e4fede37ff91ec8900f86396bbe4be07407
Author: Alexis Roche <alexis.roche@gmail.com>

    fixing a math domain error in quaternions

commit 6a6a6519fc3e5c275a61c8727b9002a3a2ae6b42
Author: Matthew Brett <matthew.brett@gmail.com>

    BF - use quaternions mathematics from transforms3d package for affine->vector

Reference: https://github.com/matthew-brett/transforms3d/issues/6
Signed-off-by: Igor Gnatenko <i.gnatenko.brain@gmail.com>
---
 transforms3d/__init__.py               |   1 +
 transforms3d/axangles.py               |   2 +-
 transforms3d/quaternions.py            |  79 +++++++++++++-------------
 transforms3d/taitbryan.py              | 100 ++++++++++++++++++++++++++-------
 transforms3d/tests/samples.py          |   1 +
 transforms3d/tests/test_quaternions.py |  74 +++++++++++++-----------
 transforms3d/tests/test_taitbryan.py   |  37 ++++++------
 transforms3d/utils.py                  |   1 +
 8 files changed, 183 insertions(+), 112 deletions(-)

diff --git a/transforms3d/__init__.py b/transforms3d/__init__.py
index 93e292a..8424cee 100644
--- a/transforms3d/__init__.py
+++ b/transforms3d/__init__.py
@@ -4,6 +4,7 @@ Based on, largely using transformations.py by Christoph Gohlke
 
 Additional code monkey work by Matthew Brett
 '''
+from __future__ import absolute_import
 
 from . import taitbryan
 from . import affines
diff --git a/transforms3d/axangles.py b/transforms3d/axangles.py
index 4d83e1c..a201ca9 100644
--- a/transforms3d/axangles.py
+++ b/transforms3d/axangles.py
@@ -22,7 +22,7 @@ def axangle2mat(axis, angle, is_normalized=False):
     axis : 3 element sequence
        vector specifying axis for rotation.
     angle : scalar
-       angle of rotation in radians.
+       angle of rotation.
     is_normalized : bool, optional
        True if `axis` is already normalized (has norm of 1).  Default False.
 
diff --git a/transforms3d/quaternions.py b/transforms3d/quaternions.py
index 5d28421..6cf1d32 100644
--- a/transforms3d/quaternions.py
+++ b/transforms3d/quaternions.py
@@ -1,5 +1,8 @@
 '''Functions to operate on, or return, quaternions.
 
+The module also includes functions for the closely related angle, axis
+pair as a specification for rotation.
+
 Quaternions here consist of 4 values ``w, x, y, z``, where ``w`` is the
 real (scalar) part, and ``x, y, z`` are the complex (vector) part.
 
@@ -19,6 +22,7 @@ Terms used in function names:
 * *quat* : quaternion shape (4,)
 * *axangle* : rotations encoded by axis vector and angle scalar
 '''
+from __future__ import absolute_import
 
 import math
 import numpy as np
@@ -82,16 +86,16 @@ def fillpositive(xyz, w2_thresh=None):
     # If necessary, guess precision of input
     if w2_thresh is None:
         try: # trap errors for non-array, integer array
-            w2_thresh = -np.finfo(xyz.dtype).eps * 3
+            w2_thresh = -np.finfo(xyz.dtype).eps
         except (AttributeError, ValueError):
-            w2_thresh = -_FLOAT_EPS * 3
+            w2_thresh = -_FLOAT_EPS
     # Use maximum precision
     xyz = np.asarray(xyz, dtype=_MAX_FLOAT)
     # Calculate w
     w2 = 1.0 - np.dot(xyz, xyz)
     if w2 < 0:
         if w2 < w2_thresh:
-            raise ValueError('w2 should be positive, but is %e' % w2)
+            raise ValueError('w2 should be positive, but is %f' % w2)
         w = 0
     else:
         w = np.sqrt(w2)
@@ -133,7 +137,7 @@ def quat2mat(q):
     '''
     w, x, y, z = q
     Nq = w*w + x*x + y*y + z*z
-    if Nq < _FLOAT_EPS:
+    if Nq == 0.0:
         return np.eye(3)
     s = 2.0/Nq
     X = x*s
@@ -173,14 +177,6 @@ def mat2quat(M):
     sign of the reconstructed quaternion is arbitrary, and we return
     quaternions with positive w (q[0]).
 
-    References
-    ----------
-    * http://en.wikipedia.org/wiki/Rotation_matrix#Quaternion
-    * Bar-Itzhack, Itzhack Y. (2000), "New method for extracting the
-      quaternion from a rotation matrix", AIAA Journal of Guidance,
-      Control and Dynamics 23(6):1085-1087 (Engineering Note), ISSN
-      0731-5090
-
     Examples
     --------
     >>> import numpy as np
@@ -211,7 +207,7 @@ def mat2quat(M):
         [Qyx + Qxy,       Qyy - Qxx - Qzz, 0,               0              ],
         [Qzx + Qxz,       Qzy + Qyz,       Qzz - Qxx - Qyy, 0              ],
         [Qyz - Qzy,       Qzx - Qxz,       Qxy - Qyx,       Qxx + Qyy + Qzz]]
-        ) / 3.0
+        ) / 3
     # Use Hermitian eigenvectors, values for speed
     vals, vecs = np.linalg.eigh(K)
     # Select largest eigenvector, reorder to w,x,y,z quaternion
@@ -223,7 +219,7 @@ def mat2quat(M):
     return q
 
 
-def qmult(q1, q2):
+def mult(q1, q2):
     ''' Multiply two quaternions
 
     Parameters
@@ -248,7 +244,7 @@ def qmult(q1, q2):
     return np.array([w, x, y, z])
 
 
-def qconjugate(q):
+def conjugate(q):
     ''' Conjugate of quaternion
 
     Parameters
@@ -264,7 +260,7 @@ def qconjugate(q):
     return np.array(q) * np.array([1.0, -1, -1, -1])
 
 
-def qnorm(q):
+def norm(q):
     ''' Return norm of quaternion
 
     Parameters
@@ -280,12 +276,12 @@ def qnorm(q):
     return np.dot(q, q)
 
 
-def qisunit(q):
+def isunit(q):
     ''' Return True is this is very nearly a unit quaternion '''
-    return np.allclose(qnorm(q), 1)
+    return np.allclose(norm(q), 1)
 
 
-def qinverse(q):
+def inverse(q):
     ''' Return multiplicative inverse of quaternion `q`
 
     Parameters
@@ -298,10 +294,10 @@ def qinverse(q):
     invq : array shape (4,)
        w, i, j, k of quaternion inverse
     '''
-    return qconjugate(q) / qnorm(q)
+    return conjugate(q) / norm(q)
 
 
-def qeye():
+def eye():
     ''' Return identity quaternion '''
     return np.array([1.0,0,0,0])
 
@@ -324,17 +320,18 @@ def rotate_vector(v, q):
     Notes
     -----
     See: http://en.wikipedia.org/wiki/Quaternions_and_spatial_rotation#Describing_rotations_with_quaternions
+
     '''
     varr = np.zeros((4,))
     varr[1:] = v
-    return qmult(q, qmult(varr, qconjugate(q)))[1:]
+    return mult(q, mult(varr, conjugate(q)))[1:]
 
 
 def nearly_equivalent(q1, q2, rtol=1e-5, atol=1e-8):
     ''' Returns True if `q1` and `q2` give near equivalent transforms
 
-    `q1` may be nearly numerically equal to `q2`, or nearly equal to `q2` * -1
-    (because a quaternion multiplied by -1 gives the same transform).
+    q1 may be nearly numerically equal to q2, or nearly equal to q2 * -1
+    (becuase a quaternion multiplied by -1 gives the same transform).
 
     Parameters
     ----------
@@ -373,7 +370,7 @@ def axangle2quat(vector, theta, is_normalized=False):
     vector : 3 element sequence
        vector specifying axis for rotation.
     theta : scalar
-       angle of rotation in radians.
+       angle of rotation.
     is_normalized : bool, optional
        True if vector is already normalized (has norm of 1).  Default
        False.
@@ -395,9 +392,7 @@ def axangle2quat(vector, theta, is_normalized=False):
     '''
     vector = np.array(vector)
     if not is_normalized:
-        # Cannot divide in-place because input vector may be integer type,
-        # whereas output will be float type; this may raise an error in versions
-        # of numpy > 1.6.1
+        # Not in place to avoid numpy's stricter casting rules
         vector = vector / math.sqrt(np.dot(vector, vector))
     t2 = theta / 2.0
     st2 = math.sin(t2)
@@ -413,10 +408,10 @@ def quat2axangle(quat, identity_thresh=None):
     quat : 4 element sequence
        w, x, y, z forming quaternion.
     identity_thresh : None or scalar, optional
-       Threshold below which the norm of the vector part of the quaternion (x,
-       y, z) is deemed to be 0, leading to the identity rotation.  None (the
-       default) leads to a threshold estimated based on the precision of the
-       input.
+       threshold below which the norm of the vector part of the
+       quaternion (x, y, z) is deemed to be 0, leading to the identity
+       rotation.  None (the default) leads to a threshold estimated
+       based on the precision of the input.
 
     Returns
     -------
@@ -433,26 +428,30 @@ def quat2axangle(quat, identity_thresh=None):
     >>> np.allclose(theta, np.pi)
     True
 
-    If this is an identity rotation, we return a zero angle and an arbitrary
-    vector:
+    If this is an identity rotation, we return a zero angle and an
+    arbitrary vector
 
     >>> quat2axangle([1, 0, 0, 0])
     (array([ 1.,  0.,  0.]), 0.0)
 
     Notes
     -----
-    A quaternion for which x, y, z are all equal to 0, is an identity rotation.
-    In this case we return a 0 angle and an arbitrary vector, here [1, 0, 0]
+    A quaternion for which x, y, z are all equal to 0, is an identity
+    rotation.  In this case we return a 0 angle and an  arbitrary
+    vector, here [1, 0, 0]
     '''
     w, x, y, z = quat
     vec = np.asarray([x, y, z])
     if identity_thresh is None:
         try:
             identity_thresh = np.finfo(vec.dtype).eps * 3
-        except ValueError: # integer type
+        except ValueError:  # integer type
             identity_thresh = _FLOAT_EPS * 3
-    n = math.sqrt(x*x + y*y + z*z)
-    if n < identity_thresh:
+    len2 = x * x + y * y + z * z
+    if len2 < identity_thresh ** 2:
         # if vec is nearly 0,0,0, this is an identity rotation
         return np.array([1.0, 0, 0]), 0.0
-    return  vec / n, 2 * math.acos(w)
+    theta = 2 * math.acos(max(min(w, 1), -1))
+    if len2 == float('inf'):
+        return np.zeros((3,)), theta
+    return vec / math.sqrt(len2), theta
diff --git a/transforms3d/taitbryan.py b/transforms3d/taitbryan.py
index a978116..a6c4f69 100644
--- a/transforms3d/taitbryan.py
+++ b/transforms3d/taitbryan.py
@@ -1,11 +1,61 @@
-''' Euler angle rotations and their conversions for Tait-Bryan zyx convention
+''' Module implementing Euler angle rotations and their conversions
 
-See :mod:`euler` for general discussion of Euler angles and conventions.
+See:
 
-This module has specialized implementations of the extrinsic Z axis, Y axis, X
-axis rotation convention.
+* http://en.wikipedia.org/wiki/Rotation_matrix
+* http://en.wikipedia.org/wiki/Euler_angles
+* http://mathworld.wolfram.com/EulerAngles.html
 
-The conventions in this module are therefore:
+See also: *Representing Attitude with Euler Angles and Quaternions: A
+Reference* (2006) by James Diebel. A cached PDF link last found here:
+
+http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.110.5134
+
+Euler's rotation theorem tells us that any rotation in 3D can be
+described by 3 angles.  Let's call the 3 angles the *Euler angle vector*
+and call the angles in the vector :math:`alpha`, :math:`beta` and
+:math:`gamma`.  The vector is [ :math:`alpha`,
+:math:`beta`. :math:`gamma` ] and, in this description, the order of the
+parameters specifies the order in which the rotations occur (so the
+rotation corresponding to :math:`alpha` is applied first).
+
+In order to specify the meaning of an *Euler angle vector* we need to
+specify the axes around which each of the rotations corresponding to
+:math:`alpha`, :math:`beta` and :math:`gamma` will occur.
+
+There are therefore three axes for the rotations :math:`alpha`,
+:math:`beta` and :math:`gamma`; let's call them :math:`i` :math:`j`,
+:math:`k`.
+
+Let us express the rotation :math:`alpha` around axis `i` as a 3 by 3
+rotation matrix `A`.  Similarly :math:`beta` around `j` becomes 3 x 3
+matrix `B` and :math:`gamma` around `k` becomes matrix `G`.  Then the
+whole rotation expressed by the Euler angle vector [ :math:`alpha`,
+:math:`beta`. :math:`gamma` ], `R` is given by::
+
+   R = np.dot(G, np.dot(B, A))
+
+See http://mathworld.wolfram.com/EulerAngles.html
+
+The order :math:`G B A` expresses the fact that the rotations are
+performed in the order of the vector (:math:`alpha` around axis `i` =
+`A` first).
+
+To convert a given Euler angle vector to a meaningful rotation, and a
+rotation matrix, we need to define:
+
+* the axes `i`, `j`, `k`
+* whether a rotation matrix should be applied on the left of a vector to
+  be transformed (vectors are column vectors) or on the right (vectors
+  are row vectors).
+* whether the rotations move the axes as they are applied (intrinsic
+  rotations) - compared the situation where the axes stay fixed and the
+  vectors move within the axis frame (extrinsic)
+* the handedness of the coordinate system
+
+See: http://en.wikipedia.org/wiki/Rotation_matrix#Ambiguities
+
+We are using the following conventions:
 
 * axes `i`, `j`, `k` are the `z`, `y`, and `x` axes respectively.  Thus
   an Euler angle vector [ :math:`alpha`, :math:`beta`. :math:`gamma` ]
@@ -32,18 +82,18 @@ Terms used in function names:
 * *axangle* : rotations encoded by axis vector and angle scalar
 * *quat* : quaternion shape (4,)
 '''
+from __future__ import absolute_import
 
 import math
-import numpy as np
-
 from functools import reduce
 
-from .axangles import axangle2mat
+import numpy as np
+
 
 _FLOAT_EPS_4 = np.finfo(float).eps * 4.0
 
 
-def euler2mat(z, y, x):
+def euler2mat(z=0, y=0, x=0):
     ''' Return matrix for rotations around z, y and x axes
 
     Uses the z, then y, then x convention above
@@ -68,19 +118,24 @@ def euler2mat(z, y, x):
     >>> yrot = -0.1
     >>> xrot = 0.2
     >>> M = euler2mat(zrot, yrot, xrot)
-    >>> M.shape == (3, 3)
-    True
+    >>> M.shape
+    (3, 3)
 
     The output rotation matrix is equal to the composition of the
     individual rotations
 
-    >>> M1 = euler2mat(zrot, 0, 0)
-    >>> M2 = euler2mat(0, yrot, 0)
+    >>> M1 = euler2mat(zrot)
+    >>> M2 = euler2mat(0, yrot)
     >>> M3 = euler2mat(0, 0, xrot)
     >>> composed_M = np.dot(M3, np.dot(M2, M1))
     >>> np.allclose(M, composed_M)
     True
 
+    You can specify rotations by named arguments
+
+    >>> np.all(M3 == euler2mat(x=xrot))
+    True
+
     When applying M to a vector, the vector should column vector to the
     right of M.  If the right hand side is a 2D array rather than a
     vector, then each column of the 2D array represents a vector.
@@ -92,13 +147,13 @@ def euler2mat(z, y, x):
 
     Rotations are counter-clockwise.
 
-    >>> zred = np.dot(euler2mat(np.pi/2, 0, 0), np.eye(3))
+    >>> zred = np.dot(euler2mat(z=np.pi/2), np.eye(3))
     >>> np.allclose(zred, [[0, -1, 0],[1, 0, 0], [0, 0, 1]])
     True
-    >>> yred = np.dot(euler2mat(0, np.pi/2, 0), np.eye(3))
+    >>> yred = np.dot(euler2mat(y=np.pi/2), np.eye(3))
     >>> np.allclose(yred, [[0, 0, 1],[0, 1, 0], [-1, 0, 0]])
     True
-    >>> xred = np.dot(euler2mat(0, 0, np.pi/2), np.eye(3))
+    >>> xred = np.dot(euler2mat(x=np.pi/2), np.eye(3))
     >>> np.allclose(xred, [[1, 0, 0],[0, 0, -1], [0, 1, 0]])
     True
 
@@ -212,7 +267,7 @@ def mat2euler(M, cy_thresh=None):
     return z, y, x
 
 
-def euler2quat(z, y, x):
+def euler2quat(z=0, y=0, x=0):
     ''' Return quaternion corresponding to these Euler angles
 
     Uses the z, then y, then x convention above
@@ -281,8 +336,8 @@ def quat2euler(q):
     return mat2euler(nq.quat2mat(q))
 
 
-def euler2axangle(z, y, x):
-    ''' Return angle, axis corresponding to these Euler angles
+def euler2axangle(z=0, y=0, x=0):
+    ''' Return axis, angle corresponding to these Euler angles
 
     Uses the z, then y, then x convention above
 
@@ -307,7 +362,7 @@ def euler2axangle(z, y, x):
     >>> vec, theta = euler2axangle(0, 1.5, 0)
     >>> np.allclose(vec, [0, 1, 0])
     True
-    >>> theta
+    >>> print(theta)
     1.5
     '''
     # delayed import to avoid cyclic dependencies
@@ -345,4 +400,7 @@ def axangle2euler(vector, theta):
     functions, but the reduction in computation is small, and the code
     repetition is large.
     '''
-    return mat2euler(axangle2mat(vector, theta))
+    # delayed import to avoid cyclic dependencies
+    from . import axangles as ax
+    M = ax.axangle2mat(vector, theta)
+    return mat2euler(M)
diff --git a/transforms3d/tests/samples.py b/transforms3d/tests/samples.py
index a895559..478e774 100644
--- a/transforms3d/tests/samples.py
+++ b/transforms3d/tests/samples.py
@@ -1,3 +1,4 @@
+from __future__ import absolute_import
 import numpy as np
 
 from ..utils import inique, permuted_signs, permuted_with_signs
diff --git a/transforms3d/tests/test_quaternions.py b/transforms3d/tests/test_quaternions.py
index 9a8998e..d5f103a 100644
--- a/transforms3d/tests/test_quaternions.py
+++ b/transforms3d/tests/test_quaternions.py
@@ -1,10 +1,20 @@
 ''' Test quaternion calculations '''
+from __future__ import absolute_import
 
 import math
 
 import numpy as np
 
-from nose.tools import (assert_raises, assert_true, assert_equal)
+# Recent (1.2) versions of numpy have this decorator
+try:
+    from numpy.testing.decorators import slow
+except ImportError:
+    def slow(t):
+        t.slow = True
+        return t
+
+from nose.tools import assert_raises, assert_true, assert_false, \
+    assert_equal
 
 from numpy.testing import assert_array_almost_equal, assert_array_equal
 
@@ -22,7 +32,7 @@ eg_pairs = list(zip(euler_mats, euler_quats))
 
 # Set of arbitrary unit quaternions
 unit_quats = set()
-params = range(-2,3)
+params = list(range(-2,3))
 for w in params:
     for x in params:
         for y in params:
@@ -38,34 +48,26 @@ def test_fillpos():
     # Takes np array
     xyz = np.zeros((3,))
     w,x,y,z = tq.fillpositive(xyz)
-    assert_equal(w, 1)
+    yield assert_true, w == 1
     # Or lists
     xyz = [0] * 3
     w,x,y,z = tq.fillpositive(xyz)
-    assert_equal(w, 1)
+    yield assert_true, w == 1
     # Errors with wrong number of values
-    assert_raises(ValueError, tq.fillpositive, [0, 0])
-    assert_raises(ValueError, tq.fillpositive, [0]*4)
+    yield assert_raises, ValueError, tq.fillpositive, [0, 0]
+    yield assert_raises, ValueError, tq.fillpositive, [0]*4
     # Errors with negative w2
-    assert_raises(ValueError, tq.fillpositive, [1.0]*3)
+    yield assert_raises, ValueError, tq.fillpositive, [1.0]*3
     # Test corner case where w is near zero
-    wxyz = tq.fillpositive([1, 0, 0])
-    assert_equal(wxyz[0], 0.0)
-    eps = np.finfo(float).eps
-    wxyz = tq.fillpositive([1 + eps, 0, 0])
-    assert_equal(wxyz[0], 0.0)
-    # Bump up the floating point error - raises error
-    assert_raises(ValueError, tq.fillpositive, [1 + eps * 3, 0, 0])
-    # Increase threshold, happy again
-    wxyz = tq.fillpositive([1 + eps * 3, 0, 0], w2_thresh=eps * -10)
-    assert_equal(wxyz[0], 0.0)
-
-
-def test_qconjugate():
+    wxyz = tq.fillpositive([1,0,0])
+    yield assert_true, wxyz[0] == 0.0
+
+
+def test_conjugate():
     # Takes sequence
-    cq = tq.qconjugate((1, 0, 0, 0))
+    cq = tq.conjugate((1, 0, 0, 0))
     # Returns float type
-    assert_true(cq.dtype.kind == 'f')
+    yield assert_true, cq.dtype.kind == 'f'
 
 
 def test_quat2mat():
@@ -82,42 +84,45 @@ def test_quat2mat():
     yield assert_array_almost_equal, M, np.eye(3)
 
 
-def test_qinverse():
+def test_inverse():
     # Takes sequence
-    iq = tq.qinverse((1, 0, 0, 0))
+    iq = tq.inverse((1, 0, 0, 0))
     # Returns float type
     yield assert_true, iq.dtype.kind == 'f'
     for M, q in eg_pairs:
-        iq = tq.qinverse(q)
+        iq = tq.inverse(q)
         iqM = tq.quat2mat(iq)
         iM = np.linalg.inv(M)
         yield assert_true, np.allclose(iM, iqM)
 
 
-def test_qeye():
-    qi = tq.qeye()
+def test_eye():
+    qi = tq.eye()
     yield assert_true, qi.dtype.kind == 'f'
     yield assert_true, np.all([1,0,0,0]==qi)
     yield assert_true, np.allclose(tq.quat2mat(qi), np.eye(3))
 
 
-def test_qnorm():
-    qi = tq.qeye()
-    yield assert_true, tq.qnorm(qi) == 1
-    yield assert_true, tq.qisunit(qi)
+def test_norm():
+    qi = tq.eye()
+    yield assert_true, tq.norm(qi) == 1
+    yield assert_true, tq.isunit(qi)
     qi[1] = 0.2
-    yield assert_true, not tq.qisunit(qi)
+    yield assert_true, not tq.isunit(qi)
 
 
-def test_qmult():
+@slow
+def test_mult():
     # Test that quaternion * same as matrix * 
     for M1, q1 in eg_pairs[0::4]:
         for M2, q2 in eg_pairs[1::4]:
-            q21 = tq.qmult(q2, q1)
+            q21 = tq.mult(q2, q1)
             yield assert_array_almost_equal, np.dot(M2,M1), tq.quat2mat(q21)
 
 
+@slow
 def test_qrotate():
+    vecs = np.eye(3)
     for vec in np.eye(3):
         for M, q in eg_pairs:
             vdash = tq.rotate_vector(vec, q)
@@ -125,6 +130,7 @@ def test_qrotate():
             yield assert_array_almost_equal, vdash, vM
 
 
+@slow
 def test_quaternion_reconstruction():
     # Test reconstruction of arbitrary unit quaternions
     for q in unit_quats:
diff --git a/transforms3d/tests/test_taitbryan.py b/transforms3d/tests/test_taitbryan.py
index 3b8ceae..7ce52ef 100644
--- a/transforms3d/tests/test_taitbryan.py
+++ b/transforms3d/tests/test_taitbryan.py
@@ -1,4 +1,5 @@
-''' Tests for Euler angles using Tait-Bryan ZYX convention '''
+''' Tests for Euler angles '''
+from __future__ import absolute_import
 
 import math
 import numpy as np
@@ -70,39 +71,43 @@ def test_basic_euler():
     # Rotation matrix composing the three rotations
     M = ttb.euler2mat(zr, yr, xr)
     # Corresponding individual rotation matrices
-    M1 = ttb.euler2mat(zr, 0, 0)
-    M2 = ttb.euler2mat(0, yr, 0)
+    M1 = ttb.euler2mat(zr)
+    M2 = ttb.euler2mat(0, yr)
     M3 = ttb.euler2mat(0, 0, xr)
     # which are all valid rotation matrices
-    assert_true(is_valid_rotation(M))
-    assert_true(is_valid_rotation(M1))
-    assert_true(is_valid_rotation(M2))
-    assert_true(is_valid_rotation(M3))
+    yield assert_true, is_valid_rotation(M)
+    yield assert_true, is_valid_rotation(M1)
+    yield assert_true, is_valid_rotation(M2)
+    yield assert_true, is_valid_rotation(M3)
     # Full matrix is composition of three individual matrices
-    assert_true(np.allclose(M, np.dot(M3, np.dot(M2, M1))))
+    yield assert_true, np.allclose(M, np.dot(M3, np.dot(M2, M1)))
+    # Rotations can be specified with named args, default 0
+    yield assert_true, np.all(ttb.euler2mat(zr) == ttb.euler2mat(z=zr))
+    yield assert_true, np.all(ttb.euler2mat(0, yr) == ttb.euler2mat(y=yr))
+    yield assert_true, np.all(ttb.euler2mat(0, 0, xr) == ttb.euler2mat(x=xr))
     # Applying an opposite rotation same as inverse (the inverse is
     # the same as the transpose, but just for clarity)
-    assert_true(np.allclose(
-        ttb.euler2mat(0, 0, -xr), np.linalg.inv(ttb.euler2mat(0, 0, xr))))
+    yield assert_true, np.allclose(ttb.euler2mat(x=-xr),
+                       np.linalg.inv(ttb.euler2mat(x=xr)))
 
 
 def test_euler_mat():
-    M = ttb.euler2mat(0, 0, 0)
-    assert_array_equal(M, np.eye(3))
+    M = ttb.euler2mat()
+    yield assert_array_equal, M, np.eye(3)
     for x, y, z in euler_tuples:
         M1 = ttb.euler2mat(z, y, x)
         M2 = sympy_euler(z, y, x)
-        assert_array_almost_equal(M1, M2)
+        yield assert_array_almost_equal, M1, M2
         M3 = np.dot(x_only(x), np.dot(y_only(y), z_only(z)))
-        assert_array_almost_equal(M1, M3)
+        yield assert_array_almost_equal, M1, M3
         zp, yp, xp = ttb.mat2euler(M1)
         # The parameters may not be the same as input, but they give the
         # same rotation matrix
         M4 = ttb.euler2mat(zp, yp, xp)
-        assert_array_almost_equal(M1, M4)
+        yield assert_array_almost_equal, M1, M4
 
 
-def sympy_euler2quat(z, y, x):
+def sympy_euler2quat(z=0, y=0, x=0):
     # direct formula for z,y,x quaternion rotations using sympy
     # see derivations subfolder
     cos = math.cos
diff --git a/transforms3d/utils.py b/transforms3d/utils.py
index d66d79d..7f38793 100644
--- a/transforms3d/utils.py
+++ b/transforms3d/utils.py
@@ -1,4 +1,5 @@
 ''' Utilities for transforms3d '''
+from __future__ import absolute_import
 
 import math
 from itertools import permutations
-- 
2.6.2

